/**
 * This transformation preprocesses try statements for jumper.
 *
 * - Finally [FILL]
 *
 * - In a catch clause, the name of the captured exception is not 'var'-bound in
 *   the enclosing function. i.e., the following program throws an exception:
 *
 *     function F() {
 *       try {
 *         throw 'x';
 *       }
 *       catch(exn) {
 *       };
 *       return exn; // free identifier
 *     }
 *     F();
 *
 *   This makes it difficult to define the jumper transformation. This
 *   transformation turns every try-catch statement:
 *
 *     try { ... } catch (exn) { ... }
 *
 *   into:
 *
 *     var exn_; try { ... } catch (exn) { exn_ = exn; ... }
 *
 *   Consider what this entails for each mode of execution:
 *   - Normal mode: no change in semantics since 'exn_' is fresh
 *   - Capture mode: if a continuation is captured in the catch block, then
 *     the value of 'exn' is saved in 'exn_'
 *   - Restore mode: the block that restores variables restores the value of
 *     'exn_'. Therefore, jumper can transfer control to the catch block by
 *     'throw exn_'.
 */
import { Visitor } from 'babel-traverse';
export default function (): {
    visitor: Visitor;
};
