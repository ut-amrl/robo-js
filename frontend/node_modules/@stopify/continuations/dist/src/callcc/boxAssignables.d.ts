/**
 * This transformation boxes certain assignable variables to preserve
 * reference equality when the stack is reconstructed.
 *
 * Preconditions:
 * 1. The freeIds pass has been applied.
 */
import * as t from 'babel-types';
import { NodePath } from 'babel-traverse';
import { Set } from 'immutable';
declare type Parent = t.Program | t.FunctionDeclaration | t.FunctionExpression;
declare type State = {
    parentPath: NodePath<Parent>;
    vars: Set<string>;
    parentPathStack: NodePath<Parent>[];
    varsStack: Set<string>[];
    liftDeclStack: t.Statement[][];
    liftAssignStack: t.Statement[][];
    opts: {
        boxes: string[];
    };
};
export declare function box(e: t.Expression): t.ObjectExpression;
export declare function plugin(): {
    visitor: {
        Program: {
            enter(this: State, path: NodePath<t.Program>): void;
            exit(this: State, path: NodePath<t.Program>): void;
        };
        ReferencedIdentifier(this: State, path: NodePath<t.Identifier>): void;
        VariableDeclaration(this: State, path: NodePath<t.VariableDeclaration>): void;
        BindingIdentifier(this: State, path: NodePath<t.Identifier>): void;
        FunctionExpression: {
            enter(this: State, path: NodePath<t.FunctionExpression>, state: any): void;
            exit(this: State, path: NodePath<t.FunctionExpression>, state: any): void;
        };
        FunctionDeclaration: {
            enter(this: State, path: NodePath<t.FunctionExpression>, state: any): void;
            exit(this: State, path: NodePath<t.FunctionExpression>, state: any): void;
        };
    };
};
export {};
