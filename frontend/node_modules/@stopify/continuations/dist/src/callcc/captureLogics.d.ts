import { NodePath } from 'babel-traverse';
import * as t from 'babel-types';
import { CompilerOpts } from '../types';
export { isNormalMode, captureExn, captureLocals, target, restoreNextFrame, stackFrameCall, runtime, topOfRuntimeStack, runtimeStack, types, };
export { lazyCaptureLogic, lazyGlobalCatch, eagerCaptureLogic, retvalCaptureLogic, fudgeCaptureLogic };
declare const types: t.Identifier;
declare const restoreNextFrame: t.Identifier;
declare const target: t.Identifier;
declare const captureLocals: t.Identifier;
declare const runtime: t.Identifier;
declare const runtimeStack: t.MemberExpression;
declare const captureExn: t.MemberExpression;
export declare const endTurnExn: t.MemberExpression;
declare const isNormalMode: t.MemberExpression;
declare const topOfRuntimeStack: t.MemberExpression;
declare const stackFrameCall: t.CallExpression;
/**
 * Wrap callsites in try/catch block, lazily building the stack on catching a
 * Capture exception, then rethrowing.
 *
 *  jumper [[ x = f_n(...args) ]] =
 *    try {
 *      if (mode === 'normal') {
 *        x = f_n(...args);
 *      } else if (mode === restoring && target === n) {
 *        x = R.stack[R.stack.length-1].f();
 *      }
 *    } catch (exn) {
 *      if (exn instanceof Capture) {
 *        exn.stack.push(stackFrame);
 *      }
 *      throw exn;
 *    }
 */
declare function lazyCaptureLogic(path: NodePath<t.AssignmentExpression>, opts: CompilerOpts): void;
declare function lazyGlobalCatch(path: NodePath<t.AssignmentExpression>, opts: CompilerOpts): void;
/**
 * Eagerly build the stack, pushing frames before applications and popping on
 * their return. Capture exns are thrown straight to the runtime, passing the
 * eagerly built stack along with it.
 *
 *  jumper [[ x = f_n(...args) ]] =
 *    if (mode === 'normal') {
 *      eagerStack.unshift(stackFrame);
 *      x = f_n(...args);
 *      eagerStack.shift();
 *    } else if (mode === 'restoring' && target === n) {
 *      // Don't have to `unshift` to rebuild stack because the eagerStack is
 *      // preserved from when the Capture exn was thrown.
 *      x = R.stack[R.stack.length-1].f();
 *      eagerStack.shift();
 *    }
 */
declare function eagerCaptureLogic(path: NodePath<t.AssignmentExpression>, opts: CompilerOpts): void;
/**
 * Special return-value to conditionally capture stack frames and propogate
 * returns up to the runtime.
 *
 *  jumper [[ x = f_n(...args) ]] =
 *    {
 *      let ret;
 *      if (mode === 'normal') {
 *        ret = f_n(...args);
 *      } else if (mode === 'restoring' && target === n) {
 *        ret = R.stack[R.stack.length-1].f();
 *      }
 *      if (ret instanceof Capture) {
 *        ret.stack.push(stackFrame);
 *        return ret;
 *      }
 *      if (mode === 'normal') x = ret;
 *    }
 */
declare function retvalCaptureLogic(path: NodePath<t.AssignmentExpression>, opts: CompilerOpts): void;
declare function fudgeCaptureLogic(path: NodePath<t.AssignmentExpression>): void;
