declare class Ok<T> {
    value: T;
    kind: 'ok';
    constructor(value: T);
    then<S>(f: (x: T) => Result<S>): Result<S>;
    map<S>(f: (x: T) => S): Result<S>;
    unwrap(): T;
}
declare class Error<T> {
    message: string;
    kind: 'error';
    constructor(message: string);
    then<S>(f: (x: T) => Result<S>): Result<S>;
    map<S>(f: (x: T) => S): Result<S>;
    unwrap(): T;
}
export declare function ok<T>(v: T): Ok<T>;
export declare function error<T>(message: string): Error<T>;
export declare function asResult<T>(f: () => T): Result<T>;
/**
 * A Result abstraction, similar to the Result type in Rust or or the Error
 * monad in Haskell. Unlike those languages, where the type of the error is
 * a type parameter, we require all errors to be strings.
 */
export declare type Result<T> = Ok<T> | Error<T>;
export {};
