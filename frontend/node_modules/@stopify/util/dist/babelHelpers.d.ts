import { NodePath } from 'babel-traverse';
import * as t from 'babel-types';
export declare type FunWithBody = t.FunctionDeclaration | t.FunctionExpression | t.ObjectMethod;
export declare function isFunWithBody(node: t.Node): node is FunWithBody;
export declare const eTrue: t.BooleanLiteral;
export declare const eFalse: t.BooleanLiteral;
export declare const eUndefined: t.Identifier;
export declare function enclosingScopeBlock(path: NodePath<t.Node>): t.Statement[];
/** Constructs an 'e1 && e2', but simplifies when either sub-expression is
 *  a literal.
 */
export declare function and(e1: t.Expression, e2: t.Expression): t.Expression;
/** Constructs an 'e1 || e2', but simplifies when either sub-expression is
 *  a literal.
 */
export declare function or(...es: t.Expression[]): t.Expression;
export declare function sIf(e: t.Expression, s1: t.Statement, s2?: t.Statement): t.Statement;
/**
 * Replaces a statement with a sequence of statements, creating a BlockStatement
 * if necessary.
 *
 * NOTE(arjun): There appears to be a bug with Babel's path.replaceWithMultiple
 * that this function works around. To witness the bug, try the ClojureScript
 * benchmarks using Babel's replaceWithMultiple instead of this function.
 *
 * @param path the path to a statement to replace
 * @param stmts a sequence of statements
 */
export declare function replaceWithStatements(path: NodePath<t.Statement>, ...stmts: t.Statement[]): void;
/**
 * Given an 'LVal' that is an identifier, produces the identifier's name.
 * Throws an exception if the 'LVal' is not an identifier.
 *
 * @param lval an l-value
 * @returns the name of the identifier, if 'lval' is an identifier
 */
export declare function lvaltoName(lval: t.LVal): string;
/**
 * Produces 'true' if 'e' is a value.
 *
 * @param e
 */
export declare function isValue(e: t.Expression | null | t.SpreadElement): boolean;
export declare function arrayPrototypeSliceCall(e: t.Expression): t.Expression;
export declare function varDecl(x: string | t.Identifier, init?: t.Expression): t.VariableDeclaration;
export declare function enclosingFunctionName(path: NodePath<t.Node>): string | undefined;
export declare function returnLast(statements: t.Statement[]): t.Statement[];
export declare type kind = 'const' | 'var' | 'let' | undefined;
export declare function letExpression(name: t.LVal, value: t.Expression, kind?: kind): t.VariableDeclaration;
