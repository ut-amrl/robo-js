import * as babel from 'babel-core';
import * as t from 'babel-types';
import { NodePath } from 'babel-traverse';
export { letExpression } from './babelHelpers';
export declare type FunctionNode = t.FunctionDeclaration | t.FunctionExpression | t.ObjectMethod;
export declare function tag<T, V>(tag: string, t: T, v: V): T & {
    [tag: string]: V;
};
export declare type Break<T> = T & {
    break_label?: t.Identifier;
};
export declare type While<T> = T & {
    continue_label?: t.Identifier;
};
export declare type NewTag<T> = T & {
    new: boolean;
};
export declare const breakLbl: <T>(t: T, v: babel.types.Identifier) => T & {
    [tag: string]: babel.types.Identifier;
};
export declare const continueLbl: <T>(t: T, v: babel.types.Identifier) => T & {
    [tag: string]: babel.types.Identifier;
};
export declare const newTag: <T>(t: T) => T & {
    [tag: string]: boolean;
};
/**
 * Traverses children of `path` and returns true if it contains any applications.
 */
export declare function containsCall<T>(path: NodePath<T>): boolean;
/**
 * Use this when the contents of the body need to be flattened.
 * @param body An array of statements
 * @returns a new block (does not update the argument)
 */
export declare function flatBodyStatement(body: t.Statement[]): t.BlockStatement;
/**
 * A simple wrapper around Babel's `transformFromAst` function.
 */
export declare function transformFromAst(path: NodePath<t.Node>, plugins: any[], ast?: boolean, code?: boolean): babel.BabelFileResult;
