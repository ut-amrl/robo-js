import { RuntimeOpts, AsyncRun } from '../types';
import { Result, Runtime } from '@stopify/continuations-runtime';
export declare enum EventProcessingMode {
    Running = 0,
    Paused = 1,
    Waiting = 2
}
export declare abstract class AbstractRunner implements AsyncRun {
    private opts;
    kind: 'ok';
    continuationsRTS: Runtime;
    private suspendRTS;
    onDone: (result: Result) => void;
    private onYield;
    private onBreakpoint;
    private breakpoints;
    private k;
    protected eventMode: EventProcessingMode;
    private eventQueue;
    private onYieldFlag;
    private mayYieldFlag;
    g: any;
    constructor(opts: RuntimeOpts);
    private mayYieldRunning;
    /**
     * Indirectly called by the stopified program.
     */
    init(rts: Runtime): this;
    /**
     * Called by the stopified program.
     */
    suspend(): void;
    /**
     * Called by the stopified program.
     */
    onEnd(result: Result): void;
    runInit(onDone: (error?: any) => void, onYield?: () => void, onBreakpoint?: (line: number) => void): void;
    abstract run(onDone: (error?: any) => void, onYield?: () => void, onBreakpoint?: (line: number) => void): void;
    pause(onPaused: (line?: number) => void): void;
    setBreakpoints(lines: number[]): void;
    resume(): void;
    step(onStep: (line: number) => void): void;
    pauseImmediate(callback: () => void): void;
    continueImmediate(x: Result): void;
    externalHOF(body: (complete: (result: Result) => void) => never): void;
    runStopifiedCode(body: () => void, callback: (x: Result) => void): void;
    processEvent(body: () => void, receiver: (x: Result) => void): void;
    private processQueuedEvents;
}
