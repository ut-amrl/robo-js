"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const generic_1 = require("../generic");
const estimators_1 = require("@stopify/estimators");
/**
 * Checks the current time whenever 'elapsedTime' is applied, instead of
 * estimating the elapsed time.
 */
function makeExact() {
    return new estimators_1.ExactTimeEstimator();
}
exports.makeExact = makeExact;
/**
 * Assumes that 'elapsedTime' is applied every 'timePerElapsed' milliseconds
 * and uses this to estimate the elapsed time.
 *
 * @param timePerElapsed time (in milliseconds) between successive calls to
 *                       'elapsedTime'
 */
function makeCountdown(timePerElapsed) {
    return new estimators_1.CountdownTimeEstimator(timePerElapsed);
}
exports.makeCountdown = makeCountdown;
/**
 * Estimates 'elapsedTime' by sampling the current time when 'elapsedTime'
 * is applied.
 *
 * We use reservoir sampling with a reservoir of size 1, thus all times are
 * equally likely to be selected.
 */
function makeSampleAverage() {
    return new estimators_1.SampleAverageTimeEstimator();
}
exports.makeSampleAverage = makeSampleAverage;
/**
 * Estimates 'elapsedTime' by periodically resampling the current time.
 *
 * @param resample Period between resamples.
 */
function makeVelocityEstimator(resample = 100) {
    return new estimators_1.VelocityEstimator(resample);
}
exports.makeVelocityEstimator = makeVelocityEstimator;
function makeEstimator(opts) {
    if (opts.estimator === 'exact') {
        return makeExact();
    }
    else if (opts.estimator === 'countdown') {
        return makeCountdown(opts.timePerElapsed);
    }
    else if (opts.estimator === 'reservoir') {
        return makeSampleAverage();
    }
    else if (opts.estimator === 'velocity') {
        return makeVelocityEstimator(opts.resampleInterval);
    }
    else {
        return generic_1.unreachable();
    }
}
exports.makeEstimator = makeEstimator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFrZUVzdGltYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ydW50aW1lL21ha2VFc3RpbWF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFDQSx3Q0FBeUM7QUFDekMsb0RBTTZCO0FBRTdCOzs7R0FHRztBQUNILFNBQWdCLFNBQVM7SUFDdkIsT0FBTyxJQUFJLCtCQUFrQixFQUFFLENBQUM7QUFDbEMsQ0FBQztBQUZELDhCQUVDO0FBQ0Q7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsYUFBYSxDQUFDLGNBQXNCO0lBQ2xELE9BQU8sSUFBSSxtQ0FBc0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUNwRCxDQUFDO0FBRkQsc0NBRUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixpQkFBaUI7SUFDL0IsT0FBTyxJQUFJLHVDQUEwQixFQUFFLENBQUM7QUFDMUMsQ0FBQztBQUZELDhDQUVDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLHFCQUFxQixDQUFDLFdBQW1CLEdBQUc7SUFDMUQsT0FBTyxJQUFJLDhCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFGRCxzREFFQztBQUVELFNBQWdCLGFBQWEsQ0FBQyxJQUFpQjtJQUM3QyxJQUFJLElBQUksQ0FBQyxTQUFTLEtBQUssT0FBTyxFQUFFO1FBQzlCLE9BQU8sU0FBUyxFQUFFLENBQUM7S0FDcEI7U0FDSSxJQUFJLElBQUksQ0FBQyxTQUFTLEtBQUssV0FBVyxFQUFFO1FBQ3ZDLE9BQU8sYUFBYSxDQUFDLElBQUksQ0FBQyxjQUFlLENBQUMsQ0FBQztLQUM1QztTQUNJLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxXQUFXLEVBQUU7UUFDdkMsT0FBTyxpQkFBaUIsRUFBRSxDQUFDO0tBQzVCO1NBQ0ksSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLFVBQVUsRUFBRTtRQUN0QyxPQUFPLHFCQUFxQixDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0tBQ3JEO1NBQ0k7UUFDSCxPQUFPLHFCQUFXLEVBQUUsQ0FBQztLQUN0QjtBQUNILENBQUM7QUFoQkQsc0NBZ0JDIn0=