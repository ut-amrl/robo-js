"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Interface for an object that estimates elapsed time.
 */
class ElapsedTimeEstimator {
    /**
     * Clean up any necessary state. Called from the runtime's `onEnd` function.
     */
    cancel() { }
}
exports.ElapsedTimeEstimator = ElapsedTimeEstimator;
class ExactTimeEstimator extends ElapsedTimeEstimator {
    constructor(last = Date.now()) {
        super();
        this.last = last;
    }
    reset() {
        this.last = Date.now();
    }
    elapsedTime() {
        return Date.now() - this.last;
    }
}
exports.ExactTimeEstimator = ExactTimeEstimator;
class CountdownTimeEstimator extends ElapsedTimeEstimator {
    constructor(timePerElapsed, i = 0) {
        super();
        this.timePerElapsed = timePerElapsed;
        this.i = i;
    }
    reset() {
        this.i = 0;
    }
    elapsedTime() {
        this.i++;
        return this.i * this.timePerElapsed;
    }
}
exports.CountdownTimeEstimator = CountdownTimeEstimator;
/** Draws a number from a geometric distribution. */
function geom(p) {
    return Math.ceil(Math.log(1 - Math.random()) / Math.log(1 - p));
}
class SampleAverageTimeEstimator extends ElapsedTimeEstimator {
    constructor(
    // total calls to elapsedTime
    i = 1, 
    // last value produced by Date.now()
    last = Date.now(), 
    // time between successive calls to elapsedTime
    timePerElapsed = 100, 
    // these many calls to elapsedTime between observations of time
    countDownFrom = geom(1 / i), 
    // countdown until we re-observe the time
    countDown = countDownFrom, 
    // number of times elapsedTime has been invoked since last reset
    elapsedTimeCounter = 0) {
        super();
        this.i = i;
        this.last = last;
        this.timePerElapsed = timePerElapsed;
        this.countDownFrom = countDownFrom;
        this.countDown = countDown;
        this.elapsedTimeCounter = elapsedTimeCounter;
    }
    elapsedTime() {
        this.i = (this.i + 1) | 0;
        this.elapsedTimeCounter = (this.elapsedTimeCounter + 1) | 0;
        if (this.countDown-- === 0) {
            const now = Date.now();
            this.timePerElapsed = (now - this.last) / this.countDownFrom;
            this.last = now;
            this.countDownFrom = geom(1 / this.i);
            this.countDown = this.countDownFrom;
        }
        return this.timePerElapsed * this.elapsedTimeCounter;
    }
    reset() {
        this.elapsedTimeCounter = 0;
    }
}
exports.SampleAverageTimeEstimator = SampleAverageTimeEstimator;
class VelocityEstimator extends ElapsedTimeEstimator {
    constructor(
    // Expected distance between resamples (units: time)
    resample, 
    // total calls to elapsedTime
    i = 1, 
    // Units: time
    lastPosition = Date.now(), 
    // Units: time / #elapsedTime
    velocityEstimate = 100000, 
    // Units: #elapsedTime;
    resampleTimespanEstimate = velocityEstimate, 
    // countdown until we re-observe the time
    countDown = 1, 
    // Distance since last reset. Units: #elapsedTime
    distance = 0) {
        super();
        this.resample = resample;
        this.i = i;
        this.lastPosition = lastPosition;
        this.velocityEstimate = velocityEstimate;
        this.resampleTimespanEstimate = resampleTimespanEstimate;
        this.countDown = countDown;
        this.distance = distance;
    }
    elapsedTime() {
        this.i = (this.i + 1) | 0;
        this.distance = (this.distance + 1) | 0;
        if (this.countDown-- === 0) {
            const currentPosition = Date.now();
            // NOTE(arjun): This is a small float. It may be a good idea to scale
            // everything up to an integer.
            this.velocityEstimate = this.resampleTimespanEstimate / (currentPosition - this.lastPosition);
            this.lastPosition = currentPosition;
            this.resampleTimespanEstimate = Math.max((this.resample * this.velocityEstimate) | 0, 10);
            this.countDown = this.resampleTimespanEstimate;
        }
        return (this.distance / this.velocityEstimate) | 0;
    }
    reset() {
        this.distance = 0;
    }
}
exports.VelocityEstimator = VelocityEstimator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWxhcHNlZFRpbWVFc3RpbWF0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZWxhcHNlZFRpbWVFc3RpbWF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7R0FFRztBQUNILE1BQXNCLG9CQUFvQjtJQVN4Qzs7T0FFRztJQUNILE1BQU0sS0FBVyxDQUFDO0NBQ25CO0FBYkQsb0RBYUM7QUFFRCxNQUFhLGtCQUFtQixTQUFRLG9CQUFvQjtJQUMxRCxZQUEyQixPQUFPLElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDMUMsS0FBSyxFQUFFLENBQUM7UUFEaUIsU0FBSSxHQUFKLElBQUksQ0FBYTtJQUU1QyxDQUFDO0lBRUQsS0FBSztRQUNILElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFRCxXQUFXO1FBQ1QsT0FBTyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztJQUNoQyxDQUFDO0NBQ0Y7QUFaRCxnREFZQztBQUVELE1BQWEsc0JBQXVCLFNBQVEsb0JBQW9CO0lBQzlELFlBQ1UsY0FBc0IsRUFDdEIsSUFBSSxDQUFDO1FBQ2IsS0FBSyxFQUFFLENBQUM7UUFGQSxtQkFBYyxHQUFkLGNBQWMsQ0FBUTtRQUN0QixNQUFDLEdBQUQsQ0FBQyxDQUFJO0lBRWYsQ0FBQztJQUVELEtBQUs7UUFDSCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNiLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ1QsT0FBTyxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7SUFDdEMsQ0FBQztDQUNGO0FBZkQsd0RBZUM7QUFFRCxvREFBb0Q7QUFDcEQsU0FBUyxJQUFJLENBQUMsQ0FBUztJQUNyQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcs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