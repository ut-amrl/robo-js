export declare type KFrame = KFrameTop | KFrameRest;
export interface KFrameTop {
    kind: 'top';
    f: () => any;
    this: any;
}
export interface KFrameRest {
    kind: 'rest';
    f: () => any;
    locals: any[];
    params: any[];
    this: any;
    index: number;
}
export declare type Stack = KFrame[];
export declare type Mode = boolean;
export declare type Result = {
    type: 'normal';
    value: any;
} | {
    type: 'exception';
    value: any;
    stack: string[];
};
export declare type CaptureMethod = 'eager' | 'retval' | 'lazy' | 'catch' | 'original' | 'fudge';
export interface Runtime {
    /**
     * Every instance of runtime has a 'kind' field that indicates the compilation
     * strategy that it supports. An alternative approach would be to have callers
     * check if the runtime is an instanceof LazyRuntime, EagerRuntime, etc.
     * But, that would allow the caller to depend on runtime-specific features.
     * The 'kind' field allows us to keep the implementation abstract, but
     * still allows callers to determine the compilation strategy for the purpose
     * of loading pre-stopified code.
     */
    kind: CaptureMethod;
    remainingStack: number;
    stackSize: number;
    restoreFrames: number;
    mode: Mode;
    stack: Stack;
    endTurn(callback: (onDone: (x: Result) => any) => any): never;
    runtime<T>(body: () => any, onDone: (x: Result) => T): T;
    captureCC(f: (k: (x: Result) => any) => any): void;
}
