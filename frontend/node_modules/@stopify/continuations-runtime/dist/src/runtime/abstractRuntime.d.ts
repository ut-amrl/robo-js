import { Result, Runtime, Stack, Mode, KFrameTop } from '../types';
import * as types from '../types';
export declare type RunResult = {
    type: 'normal';
    value: any;
} | {
    type: 'exception';
    value: any;
} | {
    type: 'capture';
    stack: Stack;
    f: (value: any) => any;
} | {
    type: 'restore';
    stack: Stack;
    savedStack: Stack;
} | {
    type: 'end-turn';
    callback: (onDone: (x: Result) => any) => any;
};
export declare class Restore {
    stack: Stack;
    savedStack: Stack;
    constructor(stack: Stack, savedStack: Stack);
}
export declare class EndTurn {
    callback: (onDone: (x: Result) => any) => void;
    constructor(callback: (onDone: (x: Result) => any) => void);
}
export declare class Capture {
    f: (k: ((x: Result) => any)) => any;
    stack: Stack;
    constructor(f: (k: ((x: Result) => any)) => any, stack: Stack);
}
export declare abstract class RuntimeImpl implements Runtime {
    stackSize: number;
    restoreFrames: number;
    capturing: boolean;
    kind: types.CaptureMethod;
    remainingStack: number;
    stack: Stack;
    savedStack: Stack;
    mode: Mode;
    /**
     *  A saved stack trace. This field is only used when a user-mode exception
     * is thrown.
     */
    stackTrace: string[];
    constructor(stackSize: number, restoreFrames: number, capturing?: boolean);
    topK(f: () => any): KFrameTop;
    runtime<T>(body: () => any, onDone: (x: Result) => T): T;
    /** jumper.ts and captureLogics.ts insert calls to pushTrace. */
    pushTrace(line: string): void;
    /** jumper.ts inserts calls to clearTrace. */
    clearTrace(): void;
    /**
     * Called when the stack needs to be captured.
     *
     * The result type cannot be any more precise than any.
     */
    abstract captureCC(f: (k: (x: Result) => any) => any): any;
    /**
     * Wraps a stack in a function that throws an exception to discard the
     * current continuation. The exception carries the provided stack with a
     * final frame that returns the supplied value. If err is provided, instead
     * of returning the supplied value, it throws an exception with the provided
     * error.
     *
     * The result type cannot be any more precise than any.
     */
    abstract makeCont(stack: Stack): (x: Result) => any;
    /**
     * Run the `body`. It can return four types of values (in the form RunResult):
     *
     * 'normal': The execution of the body terminated normally.
     * 'capture': The execution of the body resulted in a stack capturing operation.
     * 'restore': The execution of the body resulted in a stack restoration
     *            operation.
     * 'exception': The excution of the body resulted in a userland exception.
     */
    abstract abstractRun(body: () => any): RunResult;
    abstract endTurn(callback: (onDone: (x: Result) => any) => any): never;
}
