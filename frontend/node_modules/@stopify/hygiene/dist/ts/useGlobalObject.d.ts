/**
 * This module transforms programs to use `$S.g` as the global object. We use
 * the following algorithm:
 *
 * 1. At the top-level, transform `var x = e` into `$S.g.x = e`.
 * 2. At the start of the program, insert the statement `$S.g.f = f`
 *    for each top-level `function f(...) { ... }`.  i.e., function declarations
 *    are still lifted as expected.
 * 3. Track the set of identifiers bound at non-global scopes.
 * 4. If `x` is a non-binding occurrence of an identifier that isn't in the
 *    set of identifiers tracked in Step 3, transform `x` into `$S.g.x`.
 */
import * as t from 'babel-types';
import { NodePath } from 'babel-traverse';
export declare const $S: t.Identifier;
declare type S = {
    boundIds: Set<string>;
    boundIdStack: Set<string>[];
    programBody: t.Statement[];
    opts: {
        global: t.Expression;
    };
};
export declare function plugin(): {
    visitor: {
        Program(path: NodePath<t.Program>, state: S): void;
        VariableDeclaration: {
            enter(path: NodePath<t.VariableDeclaration>, state: S): void;
        };
        FunctionDeclaration(path: NodePath<t.FunctionDeclaration>, state: S): void;
        Scope: {
            enter(path: NodePath<t.Scopable>, state: S): void;
            exit(path: NodePath<t.Scopable>, state: S): void;
        };
        BindingIdentifier: {
            exit(path: NodePath<t.Identifier>, state: S): void;
        };
        ReferencedIdentifier: {
            exit(path: NodePath<t.Identifier>, state: S): void;
        };
        CallExpression(path: NodePath<t.CallExpression>, state: S): void;
    };
};
export {};
